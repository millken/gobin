package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"
)

const (
	structComment     = "gobin:binary"
	structSkipComment = "gobin:skip"
	defaultLength     = 8 //int
)

type Generator struct {
	GoFile  string
	IsDir   bool
	PkgName string
	Types   []string

	StructInfos []*StructInfo

	OutName   string
	typeSpecs map[string]ast.Expr
}

func (p *Generator) needType(comments *ast.CommentGroup) (skip, explicit bool) {
	if comments == nil {
		return
	}

	for _, v := range comments.List {
		comment := v.Text

		if len(comment) > 2 {
			switch comment[1] {
			case '/':
				// -style comment (no newline at the end)
				comment = comment[2:]
			case '*':
				/*-style comment */
				comment = comment[2 : len(comment)-2]
			}
		}

		for _, comment := range strings.Split(comment, "\n") {
			comment = strings.TrimSpace(comment)

			if strings.HasPrefix(comment, structSkipComment) {
				return true, false
			}
			if strings.HasPrefix(comment, structComment) {
				return false, true
			}
		}
	}

	return
}

type visitor struct {
	*Generator

	name string
}

func (v *visitor) Visit(n ast.Node) (w ast.Visitor) {
	switch n := n.(type) {
	case *ast.Package:
		return v
	case *ast.File:
		v.PkgName = n.Name.String()
		return v

	case *ast.GenDecl:
		skip, explicit := v.needType(n.Doc)

		if skip || explicit {
			for _, nc := range n.Specs {
				switch nct := nc.(type) {
				case *ast.TypeSpec:
					nct.Doc = n.Doc
				}
			}
		}

		return v
	case *ast.TypeSpec:
		skip, explicit := v.needType(n.Doc)
		if skip {
			return nil
		}
		if !explicit {
			return nil
		}

		v.name = n.Name.String()
		v.typeSpecs[n.Name.Name] = n.Type
		if structType, ok := n.Type.(*ast.StructType); ok {
			structInfo := &StructInfo{
				Name:   n.Name.Name,
				Fields: make([]StructField, 0, len(structType.Fields.List)),
			}

			for _, field := range structType.Fields.List {
				for _, name := range field.Names {
					structInfo.Fields = append(structInfo.Fields, StructField{
						Name: name.Name,
						Type: parseFieldType(field.Type, v.typeSpecs, 0),
					})
				}
			}
			v.StructInfos = append(v.StructInfos, structInfo)
		}
		return v
	}
	return nil
}
func (g *Generator) Parse(fname string, isDir bool) error {
	g.typeSpecs = make(map[string]ast.Expr)
	fset := token.NewFileSet()
	if isDir {
		packages, err := parser.ParseDir(fset, fname, excludeTestFiles, parser.ParseComments)
		if err != nil {
			return err
		}

		for _, pckg := range packages {
			ast.Walk(&visitor{Generator: g}, pckg)
		}
	} else {
		f, err := parser.ParseFile(fset, fname, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		ast.Walk(&visitor{Generator: g}, f)
	}
	return nil
}

func (g *Generator) Run() error {
	var output = &bytes.Buffer{}
	if err := g.Parse(g.GoFile, g.IsDir); err != nil {
		return err
	}

	code, err := g.GenerateSize()
	if err != nil {
		return err
	}
	output.Write(code)
	code, err = g.GenerateMarshal()
	if err != nil {
		return err
	}
	output.Write(code)
	code, err = g.GenerateUnmarshal()
	if err != nil {
		return err
	}
	output.Write(code)

	f, err := os.Create(g.OutName)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Fprintf(f, "// Code generated by \"gobingen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintln(f, "package ", g.PkgName)

	if len(g.Types) > 0 {
		fmt.Fprintln(f)
		fmt.Fprintln(f, "import (")
		fmt.Fprintln(f, `  "fmt"`)
		fmt.Fprintln(f, `  "github.com/millken/gobin"`)
		fmt.Fprintln(f, ")")
	}
	f.Write(output.Bytes())
	return nil
}

func sizeMapKey(out io.Writer, ft *FieldType, name string) {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "size += %d", bt.Size)
		fmt.Fprintln(out)
		if ft.Name == "string" || ft.Name == "[]byte" {
			fmt.Fprintf(out, "size += len(%s)", name)
		}
	default:
		panic("unsupported type :" + ft.Kind)
	}
}

func sizeField(out io.Writer, ft *FieldType, name string) {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "size += %d", bt.Size)
		fmt.Fprintln(out)
		if ft.Name == "string" || ft.Name == "[]byte" {
			fmt.Fprintf(out, "size += len(%s)", name)
		}

	case "slice":
		fmt.Fprintf(out, "size += %d", defaultLength)
		fmt.Fprintln(out)
		fmt.Fprintf(out, "for _, v := range %s {", name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "_ = v")
		fmt.Fprintln(out)
		sizeField(out, ft.ElemType, "v")
		fmt.Fprintln(out, "}")
	case "array":
	case "struct":
		for _, sf := range ft.Fields {
			sizeField(out, sf.Type, name+"."+sf.Name)
		}
	case "map":
	default:
		panic("unsupported type :" + ft.Kind)
	}
	fmt.Fprintln(out)
}

func (g *Generator) GenerateSize() ([]byte, error) {
	var out = &bytes.Buffer{}

	for _, si := range g.StructInfos {
		fmt.Fprintf(out, "// SizeBinary returns the size of the serialized object")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "func (o *%s) SizeBinary() int {", si.Name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "size := 0")
		fmt.Fprintln(out)
		for _, sf := range si.Fields {
			fmt.Fprintf(out, "// %s", sf.Name)
			fmt.Fprintln(out)
			switch sf.Type.Kind {
			case "basic":
				bt := basicTypes.Get(sf.Type.Name)
				if bt == nil {
					panic("unsupported basic type :" + sf.Type.Name)
				}
				fmt.Fprintf(out, "size += %d", bt.Size)
				fmt.Fprintln(out)
				if sf.Type.Name == "string" || sf.Type.Name == "[]byte" {
					fmt.Fprintf(out, "size += len(o.%s)", sf.Name)
				}
			case "slice":
				fmt.Fprintf(out, "size += %d", defaultLength)
				fmt.Fprintln(out)
				fmt.Fprintf(out, "for _, v := range o.%s {", sf.Name)
				fmt.Fprintln(out)
				fmt.Fprintln(out, "_ = v")
				fmt.Fprintln(out)
				sizeField(out, sf.Type.ElemType, "v")
				fmt.Fprintln(out, "}")
			case "array":
			case "struct":
				sizeField(out, sf.Type, "o."+sf.Name)
			case "map":
				fmt.Fprintf(out, "size += %d", defaultLength) //map size
				fmt.Fprintln(out)
				fmt.Fprintf(out, "for k, v := range o.%s {", sf.Name)
				fmt.Fprintln(out)
				fmt.Fprintln(out, "_, _ = k, v")
				sizeMapKey(out, sf.Type.KeyType, "k")
				fmt.Fprintln(out)
				sizeField(out, sf.Type.ElemType, "v")
				fmt.Fprintln(out, "}")
			default:
				panic("unsupported type :" + sf.Type.Kind)
			}
			fmt.Fprintln(out)
		}
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return size")
		fmt.Fprintln(out, "}")
	}
	return out.Bytes(), nil
}

func marshalMapKey(out io.Writer, ft *FieldType, name string) {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "if n, err = o.Marshal%s(k, data[offset:]); err != nil {", bt.Type)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintf(out, "offset += n")
		fmt.Fprintln(out)
	default:
		panic("unsupported type :" + ft.Kind)
	}
}

func marshalField(out io.Writer, ft *FieldType, name string) {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "if n, err = o.Marshal%s(%s, data[offset:]); err != nil {", bt.Type, name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintf(out, "offset += n")
		fmt.Fprintln(out)
	case "slice":
		fmt.Fprintf(out, "if n, err = o.MarshalInt(len(%s), data[offset:]); err != nil { // length", name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out, "offset += n")
		fmt.Fprintf(out, "for _, v := range %s {", name)
		fmt.Fprintln(out)
		marshalField(out, ft.ElemType, "v")
		fmt.Fprintln(out, "}")
	case "array":
	case "struct":
		for _, sf := range ft.Fields {
			marshalField(out, sf.Type, name+"."+sf.Name)
		}
	case "map":
	default:
		panic("unsupported type :" + ft.Kind)
	}
}
func (g *Generator) GenerateMarshal() ([]byte, error) {
	var out = &bytes.Buffer{}

	for _, si := range g.StructInfos {
		// MarshalBinary
		fmt.Fprintf(out, "// MarshalBinary encodes o as conform encoding.BinaryMarshaler.")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "func (o *%s) MarshalBinary() (data []byte, err error) {", si.Name)
		fmt.Fprintln(out)
		fmt.Fprintf(out, "sz := o.SizeBinary()")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "data = make([]byte, sz)")
		fmt.Fprintln(out)
		fmt.Fprintln(out, "if n, err := o.MarshalTo(data); err != nil {")
		fmt.Fprintln(out, "return nil, err")
		fmt.Fprintln(out, "}else if n != sz {")
		fmt.Fprintf(out, `return nil, fmt.Errorf("%%s size / offset different %%d : %%d", "Marshal", sz, n)`)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out, "return data, nil")
		fmt.Fprintln(out, "}")

		fmt.Fprintf(out, "// MarshalTo encodes o as conform encoding.BinaryMarshaler.")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "func (o *%s) MarshalTo(data []byte) (int, error) {", si.Name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "var (")
		fmt.Fprintln(out, "offset, n int")
		fmt.Fprintln(out, "err error")
		fmt.Fprintln(out, ")")
		fmt.Fprintln(out)
		for _, sf := range si.Fields {
			fmt.Fprintf(out, "// %s", sf.Name)
			fmt.Fprintln(out)
			switch sf.Type.Kind {
			case "basic":
				bt := basicTypes.Get(sf.Type.Name)
				if bt == nil {
					panic("unsupported basic type :" + sf.Type.Name)
				}

				fmt.Fprintf(out, "if n, err = o.Marshal%s(o.%s, data[offset:]); err != nil {", bt.Type, sf.Name)
				fmt.Fprintln(out)
				fmt.Fprintln(out, "return 0, err")
				fmt.Fprintln(out, "}")
				fmt.Fprintf(out, "offset += n")
			case "slice":
				fmt.Fprintf(out, "if n, err = o.MarshalInt(len(o.%s), data[offset:]); err != nil { // length", sf.Name)
				fmt.Fprintln(out)
				fmt.Fprintln(out, "return 0, err")
				fmt.Fprintln(out, "}")
				fmt.Fprintln(out, "offset += n")
				fmt.Fprintf(out, "for _, v := range o.%s {", sf.Name)
				fmt.Fprintln(out)
				marshalField(out, sf.Type.ElemType, "v")
				fmt.Fprintln(out, "}")
			case "array":
			case "struct":
				marshalField(out, sf.Type, "o."+sf.Name)
			case "map":
				fmt.Fprintf(out, "if n, err = o.MarshalInt(len(o.%s), data[offset:]); err != nil { // length", sf.Name)
				fmt.Fprintln(out)
				fmt.Fprintln(out, "return 0, err")
				fmt.Fprintln(out, "}")
				fmt.Fprintln(out, "offset += n")
				fmt.Fprintf(out, "for k, v := range o.%s {", sf.Name)
				fmt.Fprintln(out)
				marshalMapKey(out, sf.Type.KeyType, "k")
				marshalField(out, sf.Type.ElemType, "v")
				fmt.Fprintln(out, "}")
			default:
				panic("unsupported type :" + sf.Type.Kind)
			}
			fmt.Fprintln(out)
		}
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return offset, nil")
		fmt.Fprintln(out, "}")
	}
	return out.Bytes(), nil
}

func unmarshalMapKey(out io.Writer, ft *FieldType, name string) string {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "k0, i, err := o.Unmarshal%s(data[n:])", bt.Type)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "if err != nil {")
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintf(out, "n += i")
		fmt.Fprintln(out)
	default:
		panic("unsupported type :" + ft.Kind)
	}
	return "k0"
}

func getTypeString(expr ast.Expr) string {
	var sb strings.Builder
	buildTypeString(&sb, expr)
	return sb.String()
}

func buildTypeString(sb *strings.Builder, expr ast.Expr) {
	switch x := expr.(type) {
	case *ast.Ident:
		sb.WriteString(x.Name)
	case *ast.ArrayType:
		sb.WriteString("[]")
		buildTypeString(sb, x.Elt)
	case *ast.StructType:
		sb.WriteString("struct {\n")
		for _, field := range x.Fields.List {
			sb.WriteString("\t")
			sb.WriteString(field.Names[0].Name)
			sb.WriteString(" ")
			buildTypeString(sb, field.Type)
			if field.Tag != nil {
				sb.WriteString(" ")
				sb.WriteString(field.Tag.Value)
			}
			sb.WriteString("\n")
		}
		sb.WriteString("}")
	case *ast.SelectorExpr:
		buildTypeString(sb, x.X)
		sb.WriteString(".")
		sb.WriteString(x.Sel.Name)
	case *ast.StarExpr:
		sb.WriteString("*")
		buildTypeString(sb, x.X)
	default:
		sb.WriteString("unknown")
	}
}

func unmarshalField(out io.Writer, ft *FieldType, name string) {
	switch ft.Kind {
	case "basic":
		bt := basicTypes.Get(ft.Name)
		if bt == nil {
			panic("unsupported basic type :" + ft.Name)
		}
		fmt.Fprintf(out, "if %s, i, err = o.Unmarshal%s(data[n:]); err != nil {", name, bt.Type)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintf(out, "n += i")
		fmt.Fprintln(out)
	case "slice":
		fmt.Fprintf(out, "if l, i, err = o.UnmarshalInt(data[n:]); err != nil { // length")
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out, "n += i")
		fmt.Fprintln(out)

		if ft.Level == 0 && !strings.HasPrefix(name, "o.") {
			name = "o." + name
		}
		ftName := ft.Name
		if ftName == "[]" {
			ftName = getTypeString(ft.Expr)
		}

		fmt.Fprintf(out, "%s = make(%s, l)", name, ftName)
		fmt.Fprintln(out)
		fmt.Fprintf(out, "for i%d := range %s {", ft.Level, name)
		fmt.Fprintln(out)
		unmarshalField(out, ft.ElemType, name+"[i"+fmt.Sprintf("%d", ft.Level)+"]")
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out)
	case "array":
	case "struct":
		for _, sf := range ft.Fields {
			unmarshalField(out, sf.Type, name+"."+sf.Name)
		}
	case "map":
		fmt.Fprintf(out, "if l, i, err = o.UnmarshalInt(data[n:]); err != nil { // length")
		fmt.Fprintln(out)
		fmt.Fprintln(out, "return 0, err")
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out, "n += i")
		fmt.Fprintln(out)
		if ft.Level == 0 {
			name = "o." + name
		}

		fmt.Fprintf(out, "%s = make(%s, l)", name, ft.Name)
		fmt.Fprintln(out)
		fmt.Fprintf(out, "for k := 0;k < l; k++ {")
		fmt.Fprintln(out)
		k := unmarshalMapKey(out, ft.KeyType, name+"[k]")
		unmarshalField(out, ft.ElemType, name+"["+k+"]")
		fmt.Fprintln(out, "}")
	default:
		panic("unsupported type :" + ft.Kind)
	}
}

func (g *Generator) GenerateUnmarshal() ([]byte, error) {
	var out = &bytes.Buffer{}

	for _, si := range g.StructInfos {
		// UnmarshalBinary
		fmt.Fprintf(out, "// UnmarshalBinary decodes o as conform encoding.BinaryUnmarshaler.")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "func (o *%s) UnmarshalBinary(data []byte) error {", si.Name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "_, err := o.UnmarshalFrom(data)")
		fmt.Fprintln(out, "return err")
		fmt.Fprintln(out, "}")
		fmt.Fprintln(out)

		fmt.Fprintf(out, "// UnmarshalFrom decodes o as conform encoding.BinaryUnmarshaler.")
		fmt.Fprintln(out)
		fmt.Fprintf(out, "func (o *%s) UnmarshalFrom(data []byte) (int, error) {", si.Name)
		fmt.Fprintln(out)
		fmt.Fprintln(out, "var (")
		fmt.Fprintln(out, "i, n, l int")
		fmt.Fprintln(out, "err error")
		fmt.Fprintln(out, ")")
		fmt.Fprintln(out)
		for _, sf := range si.Fields {
			fmt.Fprintf(out, "// %s", sf.Name)
			fmt.Fprintln(out)
			switch sf.Type.Kind {
			case "basic":
				unmarshalField(out, sf.Type, "o."+sf.Name)
			case "slice":
				unmarshalField(out, sf.Type, sf.Name)
			case "array":
			case "struct":
				unmarshalField(out, sf.Type, "o."+sf.Name)
			case "map":
				unmarshalField(out, sf.Type, sf.Name)
			default:
				panic("unsupported type :" + sf.Type.Kind)
			}
			fmt.Fprintln(out)
		}
		fmt.Fprintln(out)
		fmt.Fprintln(out, "_ = l")
		fmt.Fprintln(out, "return n, nil")
		fmt.Fprintln(out, "}")

	}
	return out.Bytes(), nil
}

func excludeTestFiles(fi os.FileInfo) bool {
	return !strings.HasSuffix(fi.Name(), "_test.go")
}
